---
layout:     post
title:      chai学习笔记
subtitle:   expect使用方法
date:       2017-10-02 12:00:00
author:     DanteYu
tags:
    - chai
---

`Chai`是具有BDD/TDD风格的验证库，可以运行在node和浏览器环境中，一般和各类JavaScript框架一起使用。本文主要介绍在node环境中的使用。

为什么说`Chai`同时具有BDD或者TDD风格呢？因为`Chai`提供了不同风格的接口
* `should`和`expect`接口提供了BDD链式风格，是一种更加易读的风格
  * `tea.should.have.property('flavors').with.lengthOf(3);`
  * `expect(tea).to.have.property('flavors').with.lengthOf(3)`
* `assert`提供了更加经典的TDD验证风格
  * `assert.lengthOf(tea.flavors, 3);`

#### 安装

安装可以使用`npm install chai`。更加推荐的做法是在`package.json`里面添加chai，然后使用`npm install`去安装。

```
"devDependencies": {
  "chai": "*"
}
```

使用`*`可以让每一次执行`npm install`的时候都去下载安装`Chai`的最新版本，这在持续集成里面能发挥很大的作用。

#### chai.expect

让我们一起来看下如何使用`chai.expect`。

##### Chains Getter

下面所有的chains都可以用来增加验证表达式的可读性，读起来更接近自然语言。

* to
* be
* been
* is
* that
* which
* and
* has
* have
* with
* at
* of
* same
* but
* does

###### .equal
`.equal`应该算是验证里面用得最多的方法了，用来验证两个对象是否相等，本质是用了strictly equal (===)。`.equal(val[,msg])`接受两个参数，第一个是期望值，第二个值是可选的当验证失败时会返回的错误消息。也可以使用`.eq`

典型用法
```js
expect(1).to.equal(1);
expect('foo').to.equal('foo');
expect(1).to.equal(2, 'this is error msg');
expect('foo').to.eq('foo');
```
当`.equal`与`.deep`一起使用的时候，使用的是[deep-eql](https://github.com/chaijs/deep-eql)而不是strictly equal (===)

```js
expect({a: 1}).to.equal({a: 1}); // fail
expect({a: 1}).to.deep.equal({a: 1}); //pass
```

###### .property
`.property(name[,val[,msg]])`用来判断对象里面的key是否存在，以及在提供第二个参数`val`的情况下验证该key对应的value值

```
expect({a: 1}).to.have.property('a');
expect({a: 1}).to.have.property('a', 1);

```

当`.property`与`.deep`一起使用的时候，使用的是[deep-eql](https://github.com/chaijs/deep-eql)而不是strictly equal (===)

```
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1}); //pass
expect({x: {a: 1}}).to.have.property('x', {a: 1}); //fail
```
`.property`可以与`.own`一起使用来排除继承的属性

```js
Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.own.property('a', 1);
expect({a: 1}).to.have.property('b').but.not.own.property('b');
```

`.property`可以与`.nested`一起使用来验证多层内嵌属性

```js
expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
```
`.deep` & `.own` & `.nested`可以一起使用

```js
expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
expect({a: {b: [{c: 3}]}}).to.have.deep.nested.property('a.b[0]', {c: 3});
```

###### .include
###### .members
###### .keys
###### .throw

###### .not

`.not`可以会进行否定式验证。

```js
expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
```

不过这种方法不是特别推荐，验证应该直指具体特定的单一目标行为而不是否定式验证，因为否定式验证只是验证多个无效行为中的一个，并不能保证正确性。

```
expect(2).to.equal(2);
expect(2).to.not.equal(1);
```
很明显，上面第二种方式不是好的验证方式

###### .deep
上面有很多例子
